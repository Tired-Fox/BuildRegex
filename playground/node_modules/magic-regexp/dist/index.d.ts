declare type Flag = 'd' | 'g' | 'i' | 'm' | 's' | 'u' | 'y';
/** Generate indices for substring matches */
declare const withIndices = "d";
/** Case-insensitive search */
declare const caseInsensitive = "i";
/** Global search */
declare const global = "g";
/** Multi-line search */
declare const multiline = "m";
/** Allows `.` to match newline characters */
declare const dotAll = "s";
/** Treat a pattern as a sequence of unicode code points */
declare const unicode = "u";
/** Perform a "sticky" search that matches starting at the current position in the target string */
declare const sticky = "y";

declare type IfUnwrapped<Value extends string, Yes, No> = Value extends `(${string})` ? No : StripEscapes<Value> extends `${infer A}${infer B}` ? A extends '' ? No : B extends '' ? No : Yes : never;

interface Input<in V extends string, G extends string = never, C extends (string | undefined)[] = []> {
    /** this adds a new pattern to the current input */
    and: {
        <I extends InputSource>(input: I): Input<`${V}${GetValue<I>}`, G | (I extends Input<any, infer NewGroups> ? NewGroups : never), [
            ...C,
            ...GetCapturedGroupsArr<I>
        ]>;
        /** this adds a new pattern to the current input, with the pattern reference to a named group. */
        referenceTo: <N extends G>(groupName: N) => Input<`${V}\\k<${N}>`, G, C>;
    };
    /** this provides an alternative to the current input */
    or: <I extends InputSource>(input: I) => Input<`(?:${V}|${GetValue<I>})`, G | (I extends Input<any, infer NewGroups> ? NewGroups : never), [
        ...C,
        ...GetCapturedGroupsArr<I>
    ]>;
    /** this is a positive lookbehind. Make sure to check [browser support](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#browser_compatibility) as not all browsers support lookbehinds (notably Safari) */
    after: <I extends InputSource>(input: I) => Input<`(?<=${GetValue<I>})${V}`, G, [...GetCapturedGroupsArr<I>, ...C]>;
    /** this is a positive lookahead */
    before: <I extends InputSource>(input: I) => Input<`${V}(?=${GetValue<I>})`, G, [...C, ...GetCapturedGroupsArr<I>]>;
    /** these is a negative lookbehind. Make sure to check [browser support](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#browser_compatibility) as not all browsers support lookbehinds (notably Safari) */
    notAfter: <I extends InputSource>(input: I) => Input<`(?<!${GetValue<I>})${V}`, G, [...GetCapturedGroupsArr<I, true>, ...C]>;
    /** this is a negative lookahead */
    notBefore: <I extends InputSource>(input: I) => Input<`${V}(?!${GetValue<I>})`, G, [...C, ...GetCapturedGroupsArr<I, true>]>;
    /** repeat the previous pattern an exact number of times */
    times: {
        <N extends number>(number: N): Input<IfUnwrapped<V, `(?:${V}){${N}}`, `${V}{${N}}`>, G, C>;
        /** specify that the expression can repeat any number of times, _including none_ */
        any: () => Input<IfUnwrapped<V, `(?:${V})*`, `${V}*`>, G, C>;
        /** specify that the expression must occur at least x times */
        atLeast: <N extends number>(number: N) => Input<IfUnwrapped<V, `(?:${V}){${N},}`, `${V}{${N},}`>, G, C>;
        /** specify a range of times to repeat the previous pattern */
        between: <Min extends number, Max extends number>(min: Min, max: Max) => Input<IfUnwrapped<V, `(?:${V}){${Min},${Max}}`, `${V}{${Min},${Max}}`>, G, C>;
    };
    /** this defines the entire input so far as a named capture group. You will get type safety when using the resulting RegExp with `String.match()`. Alias for `groupedAs` */
    as: <K extends string>(key: K) => Input<V extends `(?:${infer S})` ? `(?<${K}>${S})` : `(?<${K}>${V})`, G | K, [
        V extends `(?:${infer S})` ? `(?<${K}>${S})` : `(?<${K}>${V})`,
        ...C
    ]>;
    /** this defines the entire input so far as a named capture group. You will get type safety when using the resulting RegExp with `String.match()` */
    groupedAs: <K extends string>(key: K) => Input<V extends `(?:${infer S})` ? `(?<${K}>${S})` : `(?<${K}>${V})`, G | K, [
        V extends `(?:${infer S})` ? `(?<${K}>${S})` : `(?<${K}>${V})`,
        ...C
    ]>;
    /** this capture the entire input so far as an anonymous group */
    grouped: () => Input<V extends `(?:${infer S})${infer E}` ? `(${S})${E}` : `(${V})`, G, [
        V extends `(?:${infer S})${'' | '?' | '+' | '*' | `{${string}}`}` ? `(${S})` : `(${V})`,
        ...C
    ]>;
    /** this allows you to match beginning/ends of lines with `at.lineStart()` and `at.lineEnd()` */
    at: {
        lineStart: () => Input<`^${V}`, G, C>;
        lineEnd: () => Input<`${V}$`, G, C>;
    };
    /** this allows you to mark the input so far as optional */
    optionally: () => Input<IfUnwrapped<V, `(?:${V})?`, `${V}?`>, G, C>;
    toString: () => string;
}

declare type InputSource<S extends string = string, T extends string = never> = S | Input<any, T>;
declare type GetGroup<T extends InputSource> = T extends Input<any, infer Group> ? Group : never;
declare type GetCapturedGroupsArr<T extends InputSource, MapToUndefined extends boolean = false> = T extends Input<any, any, infer CapturedGroupArr> ? MapToUndefined extends true ? {
    [K in keyof CapturedGroupArr]: undefined;
} : CapturedGroupArr : [];
declare type MapToValues<T extends InputSource[]> = T extends [
    infer First,
    ...infer Rest extends InputSource[]
] ? First extends InputSource ? [GetValue<First>, ...MapToValues<Rest>] : [] : [];
declare type MapToGroups<T extends InputSource[]> = T extends [
    infer First,
    ...infer Rest extends InputSource[]
] ? First extends Input<any, infer K> ? K | MapToGroups<Rest> : MapToGroups<Rest> : never;

declare type Escape<T extends string, EscapeChar extends string> = T extends `${infer Start}${EscapeChar}${string}` ? Start extends `${string}${EscapeChar}${string}` ? never : T extends `${Start}${infer Char}${string}` ? Char extends EscapeChar ? T extends `${Start}${Char}${infer Rest}` ? `${Start}\\${Char}${Escape<Rest, EscapeChar>}` : never : never : never : T;
declare type StripEscapes<T extends string> = T extends `${infer A}\\${infer B}` ? `${A}${B}` : T;
declare type ExactEscapeChar = '.' | '*' | '+' | '?' | '^' | '$' | '{' | '}' | '(' | ')' | '|' | '[' | ']' | '/';
declare type GetValue<T extends InputSource> = T extends string ? Escape<T, ExactEscapeChar> : T extends Input<infer R> ? R : never;

declare type Join<T extends string[], Prefix extends string = '', Joiner extends string = '|'> = T extends [infer F, ...infer R] ? F extends string ? `${Prefix}${F}${R extends string[] ? Join<R, Joiner, Joiner> : ''}` : '' : '';

/** This matches any character in the string provided */
declare const charIn: <T extends string>(chars: T) => Input<`[${Escape<T, "^" | "]" | "\\" | "-">}]`, never, []>;
/** This matches any character that is not in the string provided */
declare const charNotIn: <T extends string>(chars: T) => Input<`[^${Escape<T, "^" | "]" | "\\" | "-">}]`, never, []>;
/** This takes an array of inputs and matches any of them */
declare const anyOf: <New extends InputSource<string, never>[]>(...args: New) => Input<`(?:${Join<MapToValues<New>, "", "|">})`, MapToGroups<New>, { [K in keyof New]: New[K] extends Input<any, any, infer C extends (string | undefined)[]> ? C : string[]; } extends infer T ? T extends { [K in keyof New]: New[K] extends Input<any, any, infer C extends (string | undefined)[]> ? C : string[]; } ? T extends [infer L, ...infer R] ? L extends any[] ? [...L extends infer T_1 ? T_1 extends L ? T_1 extends [infer L, ...infer R] ? L extends any[] ? [...L extends infer T_2 ? T_2 extends L ? T_2 extends [infer L, ...infer R] ? L extends any[] ? [...L extends infer T_3 ? T_3 extends L ? T_3 extends [infer L, ...infer R] ? L extends any[] ? [...L extends infer T_4 ? T_4 extends L ? T_4 extends [infer L, ...infer R] ? L extends any[] ? [...L extends infer T_5 ? T_5 extends L ? T_5 extends [infer L, ...infer R] ? L extends any[] ? [...L extends infer T_6 ? T_6 extends L ? T_6 extends [infer L, ...infer R] ? L extends any[] ? [...L extends infer T_7 ? T_7 extends L ? T_7 extends [infer L, ...infer R] ? L extends any[] ? [...L extends infer T_8 ? T_8 extends L ? T_8 extends [infer L, ...infer R] ? L extends any[] ? [...L extends infer T_9 ? T_9 extends L ? T_9 extends [infer L, ...infer R] ? L extends any[] ? [...L extends infer T_10 ? T_10 extends L ? T_10 extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : [] : never : never, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [L, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [] : never : never, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [L, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [] : never : never, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [L, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [] : never : never, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [L, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [] : never : never, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [L, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [] : never : never, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [L, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [] : never : never, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [L, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [] : never : never, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [L, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [] : never : never, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [L, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [] : never : never, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [L, ...R extends [infer L, ...infer R] ? L extends any[] ? [...any, ...any] : [L, ...any] : []] : [] : never : never>;
declare const char: Input<".", never, []>;
declare const word: Input<"\\b\\w+\\b", never, []>;
declare const wordChar: Input<"\\w", never, []>;
declare const wordBoundary: Input<"\\b", never, []>;
declare const digit: Input<"\\d", never, []>;
declare const whitespace: Input<"\\s", never, []>;
declare const letter: Input<"[a-zA-Z]", never, []> & {
    lowercase: Input<"[a-z]", never, []>;
    uppercase: Input<"[A-Z]", never, []>;
};
declare const tab: Input<"\\t", never, []>;
declare const linefeed: Input<"\\n", never, []>;
declare const carriageReturn: Input<"\\r", never, []>;
declare const not: {
    wordChar: Input<"\\W", never, []>;
    wordBoundary: Input<"\\B", never, []>;
    digit: Input<"\\D", never, []>;
    whitespace: Input<"\\S", never, []>;
    letter: Input<"[^a-zA-Z]", never, []> & {
        lowercase: Input<"[^a-z]", never, []>;
        uppercase: Input<"[^A-Z]", never, []>;
    };
    tab: Input<"[^\\t]", never, []>;
    linefeed: Input<"[^\\n]", never, []>;
    carriageReturn: Input<"[^\\r]", never, []>;
};
/** Equivalent to `?` - this marks the input as optional */
declare const maybe: <New extends InputSource<string, never>>(str: New) => Input<IfUnwrapped<GetValue<New>, `(?:${GetValue<New>})?`, `${GetValue<New>}?`>, GetGroup<New>, GetCapturedGroupsArr<New, false>>;
/** This escapes a string input to match it exactly */
declare const exactly: <New extends InputSource<string, never>>(input: New) => Input<GetValue<New>, GetGroup<New>, GetCapturedGroupsArr<New, false>>;
/** Equivalent to `+` - this marks the input as repeatable, any number of times but at least once */
declare const oneOrMore: <New extends InputSource<string, never>>(str: New) => Input<IfUnwrapped<GetValue<New>, `(?:${GetValue<New>})+`, `${GetValue<New>}+`>, GetGroup<New>, GetCapturedGroupsArr<New, false>>;

declare const NamedGroupsS: unique symbol;
declare const ValueS: unique symbol;
declare const CapturedGroupsArrS: unique symbol;
declare const FlagsS: unique symbol;
declare type MagicRegExp<Value extends string, NamedGroups extends string | never = never, CapturedGroupsArr extends (string | undefined)[] = [], Flags extends string | never = never> = RegExp & {
    [NamedGroupsS]: NamedGroups;
    [CapturedGroupsArrS]: CapturedGroupsArr;
    [ValueS]: Value;
    [FlagsS]: Flags;
};
declare type ExtractGroups<T extends MagicRegExp<string, string, (string | undefined)[], string>> = T extends MagicRegExp<string, infer V, (string | undefined)[], string> ? V : never;
declare type StringWithHint<S extends string> = string & {
    _capturedBy: S;
};
declare type StringCapturedBy<S extends string> = StringWithHint<S>;
declare type MapToStringCapturedBy<Ar extends (string | undefined)[]> = {
    [K in keyof Ar]: Ar[K] extends string ? StringCapturedBy<Ar[K]> | undefined : undefined;
};
declare type MagicRegExpMatchArray<T extends MagicRegExp<string, string, any[], string>> = Omit<RegExpMatchArray, 'groups'> & {
    groups: Record<ExtractGroups<T>, string | undefined>;
} & {
    [index: number | string | symbol]: never;
} & (T extends MagicRegExp<string, string, infer CapturedGroupsArr, string> ? readonly [string | undefined, ...MapToStringCapturedBy<CapturedGroupsArr>] : {});

declare const createRegExp: {
    /** Create Magic RegExp from Input helper */
    <Value extends string, NamedGroups extends string = never, CapturedGroupsArr extends (string | undefined)[] = [], Flags extends Flag[] = never[]>(raw: Input<Value, NamedGroups, CapturedGroupsArr>, flags?: [...Flags] | string | Set<Flag>): MagicRegExp<`/${Value}/${Join<Flags, '', ''>}`, NamedGroups, CapturedGroupsArr, Flags[number]>;
    /** Create Magic RegExp from string, string will be sanitized */
    <Value extends string, Flags extends Flag[] = never[]>(raw: Value, flags?: [...Flags] | string | Set<Flag>): MagicRegExp<`/${Escape<Value, ExactEscapeChar>}/${Join<Flags, '', ''>}`, never, [
    ], Flags[number]>;
};

declare global {
    interface String {
        match<R extends MagicRegExp<string, string, (string | undefined)[], Exclude<Flag, 'g'>>>(regexp: R): MagicRegExpMatchArray<R> | null;
        match<R extends MagicRegExp<string, string, (string | undefined)[], 'g'>>(regexp: R): string[] | null;
        /** @deprecated String.matchAll requires global flag to be set. */
        matchAll<R extends MagicRegExp<string, string, (string | undefined)[], never>>(regexp: R): never;
        /** @deprecated String.matchAll requires global flag to be set. */
        matchAll<R extends MagicRegExp<string, string, (string | undefined)[], Exclude<Flag, 'g'>>>(regexp: R): never;
        matchAll<R extends MagicRegExp<string, string, (string | undefined)[], string>>(regexp: R): IterableIterator<MagicRegExpMatchArray<R>>;
        /** @deprecated String.replaceAll requires global flag to be set. */
        replaceAll<R extends MagicRegExp<string, string, (string | undefined)[], never>>(searchValue: R, replaceValue: string | ((substring: string, ...args: any[]) => string)): never;
        /** @deprecated String.replaceAll requires global flag to be set. */
        replaceAll<R extends MagicRegExp<string, string, (string | undefined)[], Exclude<Flag, 'g'>>>(searchValue: R, replaceValue: string | ((substring: string, ...args: any[]) => string)): never;
    }
}

export { Flag, Input, MagicRegExp, MagicRegExpMatchArray, MapToStringCapturedBy, StringCapturedBy, anyOf, carriageReturn, caseInsensitive, char, charIn, charNotIn, createRegExp, digit, dotAll, exactly, global, letter, linefeed, maybe, multiline, not, oneOrMore, sticky, tab, unicode, whitespace, withIndices, word, wordBoundary, wordChar };
