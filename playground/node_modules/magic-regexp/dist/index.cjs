'use strict';

const NO_WRAP_RE = /^(\(.*\)|\\?.)$/;
const wrap = (s) => {
  const v = s.toString();
  return NO_WRAP_RE.test(v) ? v : `(?:${v})`;
};

const GROUPED_AS_REPLACE_RE = /^(?:\(\?:(.+)\)|(\(?.+\)?))$/;
const GROUPED_REPLACE_RE = /^(?:\(\?:(.+)\)([?+*]|{[\d,]+})?|(.+))$/;
const createInput = (s) => {
  const groupedAsFn = (key) => createInput(`(?<${key}>${`${s}`.replace(GROUPED_AS_REPLACE_RE, "$1$2")})`);
  return {
    toString: () => s.toString(),
    and: Object.assign((input) => createInput(`${s}${exactly(input)}`), {
      referenceTo: (groupName) => createInput(`${s}\\k<${groupName}>`)
    }),
    or: (input) => createInput(`(?:${s}|${exactly(input)})`),
    after: (input) => createInput(`(?<=${exactly(input)})${s}`),
    before: (input) => createInput(`${s}(?=${exactly(input)})`),
    notAfter: (input) => createInput(`(?<!${exactly(input)})${s}`),
    notBefore: (input) => createInput(`${s}(?!${exactly(input)})`),
    times: Object.assign((number) => createInput(`${wrap(s)}{${number}}`), {
      any: () => createInput(`${wrap(s)}*`),
      atLeast: (min) => createInput(`${wrap(s)}{${min},}`),
      between: (min, max) => createInput(`${wrap(s)}{${min},${max}}`)
    }),
    optionally: () => createInput(`${wrap(s)}?`),
    as: groupedAsFn,
    groupedAs: groupedAsFn,
    grouped: () => createInput(`${s}`.replace(GROUPED_REPLACE_RE, "($1$3)$2")),
    at: {
      lineStart: () => createInput(`^${s}`),
      lineEnd: () => createInput(`${s}$`)
    }
  };
};

const ESCAPE_REPLACE_RE = /[.*+?^${}()|[\]\\/]/g;
const charIn = (chars) => createInput(`[${chars.replace(/[-\\^\]]/g, "\\$&")}]`);
const charNotIn = (chars) => createInput(`[^${chars.replace(/[-\\^\]]/g, "\\$&")}]`);
const anyOf = (...args) => createInput(`(?:${args.map((a) => exactly(a)).join("|")})`);
const char = createInput(".");
const word = createInput("\\b\\w+\\b");
const wordChar = createInput("\\w");
const wordBoundary = createInput("\\b");
const digit = createInput("\\d");
const whitespace = createInput("\\s");
const letter = Object.assign(createInput("[a-zA-Z]"), {
  lowercase: createInput("[a-z]"),
  uppercase: createInput("[A-Z]")
});
const tab = createInput("\\t");
const linefeed = createInput("\\n");
const carriageReturn = createInput("\\r");
const not = {
  wordChar: createInput("\\W"),
  wordBoundary: createInput("\\B"),
  digit: createInput("\\D"),
  whitespace: createInput("\\S"),
  letter: Object.assign(createInput("[^a-zA-Z]"), {
    lowercase: createInput("[^a-z]"),
    uppercase: createInput("[^A-Z]")
  }),
  tab: createInput("[^\\t]"),
  linefeed: createInput("[^\\n]"),
  carriageReturn: createInput("[^\\r]")
};
const maybe = (str) => createInput(`${wrap(exactly(str))}?`);
const exactly = (input) => typeof input === "string" ? createInput(input.replace(ESCAPE_REPLACE_RE, "\\$&")) : input;
const oneOrMore = (str) => createInput(`${wrap(exactly(str))}+`);

const withIndices = "d";
const caseInsensitive = "i";
const global = "g";
const multiline = "m";
const dotAll = "s";
const unicode = "u";
const sticky = "y";

const createRegExp = (raw, flags) => new RegExp(exactly(raw).toString(), [...flags || ""].join(""));

exports.anyOf = anyOf;
exports.carriageReturn = carriageReturn;
exports.caseInsensitive = caseInsensitive;
exports.char = char;
exports.charIn = charIn;
exports.charNotIn = charNotIn;
exports.createRegExp = createRegExp;
exports.digit = digit;
exports.dotAll = dotAll;
exports.exactly = exactly;
exports.global = global;
exports.letter = letter;
exports.linefeed = linefeed;
exports.maybe = maybe;
exports.multiline = multiline;
exports.not = not;
exports.oneOrMore = oneOrMore;
exports.sticky = sticky;
exports.tab = tab;
exports.unicode = unicode;
exports.whitespace = whitespace;
exports.withIndices = withIndices;
exports.word = word;
exports.wordBoundary = wordBoundary;
exports.wordChar = wordChar;
